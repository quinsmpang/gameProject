<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Irrlicht Engine: irr::video::IGPUProgrammingServices Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table class="irrlicht" >
  <tr valign="middle"> 
    <td><font size="2"><a class="qindex" href="index.html"><font color="#FFFFFF">Home</font></a> 
      | <a class="qindex" href="namespaces.html"><font color="#FFFFFF">Namespaces</font></a> 
      | <a class="qindex" href="hierarchy.html"><font color="#FFFFFF">Hierarchy</font></a> 
      | <a class="qindex" href="classes.html"><font color="#FFFFFF">Alphabetical 
      List</font></a> | <a class="qindex" href="annotated.html"><font color="#FFFFFF"> 
      Class list</font></a> | <a class="qindex" href="files.html"><font color="#FFFFFF">Files</font></a> 
      | <a class="qindex" href="namespacemembers.html"><font color="#FFFFFF"> 
      Namespace&nbsp;Members</font></a> | <a class="qindex" href="functions.html"><font color="#FFFFFF">Class 
      members</font></a> | <a class="qindex" href="globals.html"><font color="#FFFFFF">File 
      members</font></a> | <a class="qindex" href="pages.html"><font color="#FFFFFF">Tutorials</font></a></font> </td>
  </tr>
</table>
<!-- Generated by Doxygen 1.6.2 -->
  <div class="navpath"><a class="el" href="namespaceirr.html">irr</a>::<a class="el" href="namespaceirr_1_1video.html">video</a>::<a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html">IGPUProgrammingServices</a>
  </div>
<div class="contents">
<h1>irr::video::IGPUProgrammingServices Class Reference</h1><!-- doxytag: class="irr::video::IGPUProgrammingServices" -->
<p>Interface making it possible to create and use programs running on the GPU.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>&gt;</code></p>

<p><a href="classirr_1_1video_1_1_i_g_p_u_programming_services-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#ad970aa24e1493f95e8240d9003334acd">addHighLevelShaderMaterial</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderProgram=0, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convenience function for use without geometry shaders  <a href="#ad970aa24e1493f95e8240d9003334acd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a51d8b03d12a4a03ca8f03efd9f3da73b">addHighLevelShaderMaterial</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a> vsCompileTarget, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a> psCompileTarget, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *geometryShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> inType=scene::EPT_TRIANGLES, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> outType=scene::EPT_TRIANGLE_STRIP, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> verticesOut=0, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new high-level shading material renderer to the VideoDriver.  <a href="#a51d8b03d12a4a03ca8f03efd9f3da73b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a17a3e2a17b9f8a391c9ad9d7e52e8719">addHighLevelShaderMaterialFromFiles</a> (<a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *vertexShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, <a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *pixelShaderProgram=0, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convenience function for use without geometry shaders  <a href="#a17a3e2a17b9f8a391c9ad9d7e52e8719"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a2c61a3622927d768ce756318b0dcf8f3">addHighLevelShaderMaterialFromFiles</a> (<a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *vertexShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a> vsCompileTarget, <a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *pixelShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a> psCompileTarget, <a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *geometryShaderProgram, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> inType=scene::EPT_TRIANGLES, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> outType=scene::EPT_TRIANGLE_STRIP, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> verticesOut=0, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files.  <a href="#a2c61a3622927d768ce756318b0dcf8f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a6a3ad46cf6516499dffae78f4849a481">addHighLevelShaderMaterialFromFiles</a> (const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;vertexShaderProgramFileName, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;pixelShaderProgramFileName=&quot;&quot;, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">convenience function for use without geometry shaders  <a href="#a6a3ad46cf6516499dffae78f4849a481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a63db9ae2f1684a888ac491278eeb8585">addHighLevelShaderMaterialFromFiles</a> (const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;vertexShaderProgramFileName, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a> vsCompileTarget, const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;pixelShaderProgramFileName, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderEntryPointName, <a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a> psCompileTarget, const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;geometryShaderProgramFileName, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> inType=scene::EPT_TRIANGLES, <a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a> outType=scene::EPT_TRIANGLE_STRIP, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> verticesOut=0, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files.  <a href="#a63db9ae2f1684a888ac491278eeb8585"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293">addShaderMaterial</a> (const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *vertexShaderProgram=0, const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *pixelShaderProgram=0, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds a new ASM shader material renderer to the VideoDriver.  <a href="#af7c7515773d4be33e1c66b8e3b65c293"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a46042ab1425d6c20f5d148febd7d9f00">addShaderMaterialFromFiles</a> (const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;vertexShaderProgramFileName, const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;pixelShaderProgramFileName, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files.  <a href="#a46042ab1425d6c20f5d148febd7d9f00"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a3d525d13fe863dc4f06af01eb44ea9e6">addShaderMaterialFromFiles</a> (<a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *vertexShaderProgram, <a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *pixelShaderProgram, <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *callback=0, <a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a> baseMaterial=video::EMT_SOLID, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> userData=0)=0</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files.  <a href="#a3d525d13fe863dc4f06af01eb44ea9e6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a09d143ea5c55840c15ebcb84e8539bc0">~IGPUProgrammingServices</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#a09d143ea5c55840c15ebcb84e8539bc0"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>Interface making it possible to create and use programs running on the GPU. </p>

<p>Definition at line <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00023">23</a> of file <a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a09d143ea5c55840c15ebcb84e8539bc0"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::~IGPUProgrammingServices" ref="a09d143ea5c55840c15ebcb84e8539bc0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual irr::video::IGPUProgrammingServices::~IGPUProgrammingServices </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline, virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>

<p>Definition at line <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00028">28</a> of file <a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>.</p>

<p>References <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a51d8b03d12a4a03ca8f03efd9f3da73b">addHighLevelShaderMaterial()</a>, <a class="el" href="_e_shader_types_8h_source.html#l00074">irr::video::EGST_GS_4_0</a>, <a class="el" href="_e_primitive_types_8h_source.html#l00030">irr::scene::EPT_TRIANGLE_STRIP</a>, and <a class="el" href="_e_primitive_types_8h_source.html#l00037">irr::scene::EPT_TRIANGLES</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ad970aa24e1493f95e8240d9003334acd"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterial" ref="ad970aa24e1493f95e8240d9003334acd" args="(const c8 *vertexShaderProgram, const c8 *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, const c8 *pixelShaderProgram=0, const c8 *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em> = <code>EVST_VS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em> = <code>EPST_PS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convenience function for use without geometry shaders </p>

<p>Definition at line <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00089">89</a> of file <a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>.</p>

<p>References <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a51d8b03d12a4a03ca8f03efd9f3da73b">addHighLevelShaderMaterial()</a>, <a class="el" href="_e_shader_types_8h_source.html#l00074">irr::video::EGST_GS_4_0</a>, <a class="el" href="_e_primitive_types_8h_source.html#l00030">irr::scene::EPT_TRIANGLE_STRIP</a>, and <a class="el" href="_e_primitive_types_8h_source.html#l00037">irr::scene::EPT_TRIANGLES</a>.</p>

</div>
</div>
<a class="anchor" id="a51d8b03d12a4a03ca8f03efd9f3da73b"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterial" ref="a51d8b03d12a4a03ca8f03efd9f3da73b" args="(const c8 *vertexShaderProgram, const c8 *vertexShaderEntryPointName, E_VERTEX_SHADER_TYPE vsCompileTarget, const c8 *pixelShaderProgram, const c8 *pixelShaderEntryPointName, E_PIXEL_SHADER_TYPE psCompileTarget, const c8 *geometryShaderProgram, const c8 *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, scene::E_PRIMITIVE_TYPE inType=scene::EPT_TRIANGLES, scene::E_PRIMITIVE_TYPE outType=scene::EPT_TRIANGLE_STRIP, u32 verticesOut=0, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>geometryShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>geometryShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a3aad41cbdf894faaeeadf465592af18f">E_GEOMETRY_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>gsCompileTarget</em> = <code>EGST_GS_4_0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>inType</em> = <code>scene::EPT_TRIANGLES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>outType</em> = <code>scene::EPT_TRIANGLE_STRIP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>verticesOut</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a new high-level shading material renderer to the VideoDriver. </p>
<p>Currently only HLSL/D3D9 and GLSL/OpenGL are supported. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgram,:</em>&nbsp;</td><td>String containing the source of the vertex shader program. This can be 0 if no vertex program shall be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderEntryPointName,:</em>&nbsp;</td><td>Name of the entry function of the vertexShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vsCompileTarget,:</em>&nbsp;</td><td>Vertex shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgram,:</em>&nbsp;</td><td>String containing the source of the pixel shader program. This can be 0 if no pixel shader shall be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the pixelShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psCompileTarget,:</em>&nbsp;</td><td>Pixel shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderProgram,:</em>&nbsp;</td><td>String containing the source of the geometry shader program. This can be 0 if no geometry shader shall be used. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the geometryShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gsCompileTarget,:</em>&nbsp;</td><td>Geometry shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inType</em>&nbsp;</td><td>Type of vertices passed to geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outType</em>&nbsp;</td><td>Type of vertices created by geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verticesOut</em>&nbsp;</td><td>Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an implementation of <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html" title="Interface making it possible to set constants for gpu programs every frame.">IShaderConstantSetCallBack</a> in which you can set the needed vertex, pixel, and geometry shader program constants. Set this to 0 if you don't need this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>Base material which renderstates will be used to shade the material. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log and can be catched with a custom event receiver. </dd></dl>

<p>Referenced by <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00089">addHighLevelShaderMaterial()</a>, and <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00028">~IGPUProgrammingServices()</a>.</p>

</div>
</div>
<a class="anchor" id="a17a3e2a17b9f8a391c9ad9d7e52e8719"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles" ref="a17a3e2a17b9f8a391c9ad9d7e52e8719" args="(io::IReadFile *vertexShaderProgram, const c8 *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, io::IReadFile *pixelShaderProgram=0, const c8 *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em> = <code>EVST_VS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em> = <code>EPST_PS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convenience function for use without geometry shaders </p>

<p>Definition at line <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00247">247</a> of file <a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>.</p>

<p>References <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a63db9ae2f1684a888ac491278eeb8585">addHighLevelShaderMaterialFromFiles()</a>, <a class="el" href="_e_shader_types_8h_source.html#l00074">irr::video::EGST_GS_4_0</a>, <a class="el" href="_e_primitive_types_8h_source.html#l00030">irr::scene::EPT_TRIANGLE_STRIP</a>, and <a class="el" href="_e_primitive_types_8h_source.html#l00037">irr::scene::EPT_TRIANGLES</a>.</p>

</div>
</div>
<a class="anchor" id="a2c61a3622927d768ce756318b0dcf8f3"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles" ref="a2c61a3622927d768ce756318b0dcf8f3" args="(io::IReadFile *vertexShaderProgram, const c8 *vertexShaderEntryPointName, E_VERTEX_SHADER_TYPE vsCompileTarget, io::IReadFile *pixelShaderProgram, const c8 *pixelShaderEntryPointName, E_PIXEL_SHADER_TYPE psCompileTarget, io::IReadFile *geometryShaderProgram, const c8 *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, scene::E_PRIMITIVE_TYPE inType=scene::EPT_TRIANGLES, scene::E_PRIMITIVE_TYPE outType=scene::EPT_TRIANGLE_STRIP, u32 verticesOut=0, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>geometryShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>geometryShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a3aad41cbdf894faaeeadf465592af18f">E_GEOMETRY_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>gsCompileTarget</em> = <code>EGST_GS_4_0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>inType</em> = <code>scene::EPT_TRIANGLES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>outType</em> = <code>scene::EPT_TRIANGLE_STRIP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>verticesOut</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgram,:</em>&nbsp;</td><td>Text file handle containing the source of the vertex shader program. Set to 0 if no vertex shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderEntryPointName,:</em>&nbsp;</td><td>Name of the entry function of the vertexShaderProgram </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vsCompileTarget,:</em>&nbsp;</td><td>Vertex shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgram,:</em>&nbsp;</td><td>Text file handle containing the source of the pixel shader program. Set to 0 if no pixel shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the pixelShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psCompileTarget,:</em>&nbsp;</td><td>Pixel shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderProgram,:</em>&nbsp;</td><td>Text file handle containing the source of the geometry shader program. Set to 0 if no geometry shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the geometryShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gsCompileTarget,:</em>&nbsp;</td><td>Geometry shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inType</em>&nbsp;</td><td>Type of vertices passed to geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outType</em>&nbsp;</td><td>Type of vertices created by geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verticesOut</em>&nbsp;</td><td>Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an implementation of <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html" title="Interface making it possible to set constants for gpu programs every frame.">IShaderConstantSetCallBack</a> in which you can set the needed vertex and pixel shader program constants. Set this to 0 if you don't need this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>Base material which renderstates will be used to shade the material. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log and can be catched with a custom event receiver. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3ad46cf6516499dffae78f4849a481"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles" ref="a6a3ad46cf6516499dffae78f4849a481" args="(const io::path &amp;vertexShaderProgramFileName, const c8 *vertexShaderEntryPointName=&quot;main&quot;, E_VERTEX_SHADER_TYPE vsCompileTarget=EVST_VS_1_1, const io::path &amp;pixelShaderProgramFileName=&quot;&quot;, const c8 *pixelShaderEntryPointName=&quot;main&quot;, E_PIXEL_SHADER_TYPE psCompileTarget=EPST_PS_1_1, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em> = <code>EVST_VS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgramFileName</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em> = <code>EPST_PS_1_1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>convenience function for use without geometry shaders </p>

<p>Definition at line <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00169">169</a> of file <a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a>.</p>

<p>References <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#a63db9ae2f1684a888ac491278eeb8585">addHighLevelShaderMaterialFromFiles()</a>, <a class="el" href="_e_shader_types_8h_source.html#l00074">irr::video::EGST_GS_4_0</a>, <a class="el" href="_e_primitive_types_8h_source.html#l00030">irr::scene::EPT_TRIANGLE_STRIP</a>, and <a class="el" href="_e_primitive_types_8h_source.html#l00037">irr::scene::EPT_TRIANGLES</a>.</p>

</div>
</div>
<a class="anchor" id="a63db9ae2f1684a888ac491278eeb8585"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles" ref="a63db9ae2f1684a888ac491278eeb8585" args="(const io::path &amp;vertexShaderProgramFileName, const c8 *vertexShaderEntryPointName, E_VERTEX_SHADER_TYPE vsCompileTarget, const io::path &amp;pixelShaderProgramFileName, const c8 *pixelShaderEntryPointName, E_PIXEL_SHADER_TYPE psCompileTarget, const io::path &amp;geometryShaderProgramFileName, const c8 *geometryShaderEntryPointName=&quot;main&quot;, E_GEOMETRY_SHADER_TYPE gsCompileTarget=EGST_GS_4_0, scene::E_PRIMITIVE_TYPE inType=scene::EPT_TRIANGLES, scene::E_PRIMITIVE_TYPE outType=scene::EPT_TRIANGLE_STRIP, u32 verticesOut=0, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addHighLevelShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a9decae50d4dc2455e7b009f5c71b24f9">E_VERTEX_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>vsCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderEntryPointName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a07fb77e9aec681402ad376f7ef9b724c">E_PIXEL_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>psCompileTarget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>geometryShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>geometryShaderEntryPointName</em> = <code>&quot;main&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#a3aad41cbdf894faaeeadf465592af18f">E_GEOMETRY_SHADER_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>gsCompileTarget</em> = <code>EGST_GS_4_0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>inType</em> = <code>scene::EPT_TRIANGLES</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1scene.html#a5d7de82f2169761194b2f44d95cdc1dc">scene::E_PRIMITIVE_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>outType</em> = <code>scene::EPT_TRIANGLE_STRIP</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>verticesOut</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgramFileName,:</em>&nbsp;</td><td>Text file containing the source of the vertex shader program. Set to empty string if no vertex shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderEntryPointName,:</em>&nbsp;</td><td>Name of the entry function of the vertexShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vsCompileTarget,:</em>&nbsp;</td><td>Vertex shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgramFileName,:</em>&nbsp;</td><td>Text file containing the source of the pixel shader program. Set to empty string if no pixel shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the pixelShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>psCompileTarget,:</em>&nbsp;</td><td>Pixel shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderProgramFileName,:</em>&nbsp;</td><td>Name of the source of the geometry shader program. Set to empty string if no geometry shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>geometryShaderEntryPointName,:</em>&nbsp;</td><td>Entry name of the function of the geometryShaderProgram (p.e. "main") </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>gsCompileTarget,:</em>&nbsp;</td><td>Geometry shader version the high level shader shall be compiled to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>inType</em>&nbsp;</td><td>Type of vertices passed to geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>outType</em>&nbsp;</td><td>Type of vertices created by geometry shader </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>verticesOut</em>&nbsp;</td><td>Maximal number of vertices created by geometry shader. If 0, maximal number supported is assumed. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an implementation of <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html" title="Interface making it possible to set constants for gpu programs every frame.">IShaderConstantSetCallBack</a> in which you can set the needed vertex, pixel, and geometry shader program constants. Set this to 0 if you don't need this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>Base material which renderstates will be used to shade the material. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured, e.g. if a shader program could not be compiled or a compile target is not reachable. The error strings are then printed to the error log and can be catched with a custom event receiver. </dd></dl>

<p>Referenced by <a class="el" href="_i_g_p_u_programming_services_8h_source.html#l00169">addHighLevelShaderMaterialFromFiles()</a>.</p>

</div>
</div>
<a class="anchor" id="af7c7515773d4be33e1c66b8e3b65c293"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addShaderMaterial" ref="af7c7515773d4be33e1c66b8e3b65c293" args="(const c8 *vertexShaderProgram=0, const c8 *pixelShaderProgram=0, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addShaderMaterial </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceirr.html#a9395eaea339bcb546b319e9c96bf7410">c8</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds a new ASM shader material renderer to the VideoDriver. </p>
<p>Note that it is a good idea to call <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#adde468368b77441ada246e1603da4f47" title="Queries the features of the driver.">IVideoDriver::queryFeature()</a> in advance to check if the <a class="el" href="classirr_1_1video_1_1_i_video_driver.html" title="Interface to driver which is able to perform 2d and 3d graphics functions.">IVideoDriver</a> supports the vertex and/or pixel shader version your are using.</p>
<p>The material is added to the VideoDriver like with <a class="el" href="classirr_1_1video_1_1_i_video_driver.html#a0dfc3a7168f3a73a6f4323b579f03ff6" title="Adds a new material renderer to the video device.">IVideoDriver::addMaterialRenderer()</a> and can be used like it had been added with that method. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgram,:</em>&nbsp;</td><td>String containing the source of the vertex shader program. This can be 0 if no vertex program shall be used.</td></tr>
  </table>
  </dd>
</dl>
<p>For DX8 programs, the will always input registers look like this: v0: position, v1: normal, v2: color, v3: texture cooridnates, v4: texture coordinates 2 if available.</p>
<p>For DX9 programs, you can manually set the registers using the dcl_ statements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgram,:</em>&nbsp;</td><td>String containing the source of the pixel shader program. This can be 0 if you don't want to use a pixel shader. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an implementation of <a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html" title="Interface making it possible to set constants for gpu programs every frame.">IShaderConstantSetCallBack</a> in which you can set the needed vertex and pixel shader program constants. Set this to 0 if you don't need this. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>Base material which renderstates will be used to shade the material. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. -1 is returned for example if a vertex or pixel shader program could not be compiled, the error strings are then printed out into the error log, and can be catched with a custom event receiver. </dd></dl>

</div>
</div>
<a class="anchor" id="a46042ab1425d6c20f5d148febd7d9f00"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addShaderMaterialFromFiles" ref="a46042ab1425d6c20f5d148febd7d9f00" args="(const io::path &amp;vertexShaderProgramFileName, const io::path &amp;pixelShaderProgramFileName, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1string.html">io::path</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgramFileName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgramFileName,:</em>&nbsp;</td><td>Text file name containing the source of the vertex shader program. Set to 0 if no shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgramFileName,:</em>&nbsp;</td><td>Text file name containing the source of the pixel shader program. Set to 0 if no shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an IShaderConstantSetCallback object on which the OnSetConstants function is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>baseMaterial </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. -1 is returned for example if a vertex or pixel shader program could not be compiled, the error strings are then printed out into the error log, and can be catched with a custom event receiver. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d525d13fe863dc4f06af01eb44ea9e6"></a><!-- doxytag: member="irr::video::IGPUProgrammingServices::addShaderMaterialFromFiles" ref="a3d525d13fe863dc4f06af01eb44ea9e6" args="(io::IReadFile *vertexShaderProgram, io::IReadFile *pixelShaderProgram, IShaderConstantSetCallBack *callback=0, E_MATERIAL_TYPE baseMaterial=video::EMT_SOLID, s32 userData=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> irr::video::IGPUProgrammingServices::addShaderMaterialFromFiles </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>vertexShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1io_1_1_i_read_file.html">io::IReadFile</a> *&nbsp;</td>
          <td class="paramname"> <em>pixelShaderProgram</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classirr_1_1video_1_1_i_shader_constant_set_call_back.html">IShaderConstantSetCallBack</a> *&nbsp;</td>
          <td class="paramname"> <em>callback</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1video.html#ac8e9b6c66f7cebabd1a6d30cbc5430f1">E_MATERIAL_TYPE</a>&nbsp;</td>
          <td class="paramname"> <em>baseMaterial</em> = <code>video::EMT_SOLID</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>userData</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Like <a class="el" href="classirr_1_1video_1_1_i_g_p_u_programming_services.html#af7c7515773d4be33e1c66b8e3b65c293" title="Adds a new ASM shader material renderer to the VideoDriver.">IGPUProgrammingServices::addShaderMaterial()</a>, but loads from files. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertexShaderProgram,:</em>&nbsp;</td><td>Text file containing the source of the vertex shader program. Set to 0 if no shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pixelShaderProgram,:</em>&nbsp;</td><td>Text file containing the source of the pixel shader program. Set to 0 if no shader shall be created. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>callback,:</em>&nbsp;</td><td>Pointer to an IShaderConstantSetCallback object to which the OnSetConstants function is called. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>baseMaterial,:</em>&nbsp;</td><td>baseMaterial </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>userData,:</em>&nbsp;</td><td>a user data int. This int can be set to any value and will be set as parameter in the callback method when calling OnSetConstants(). In this way it is easily possible to use the same callback method for multiple materials and distinguish between them during the call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Returns the number of the material type which can be set in <a class="el" href="classirr_1_1video_1_1_s_material.html#a8cb63ab4b49ae1c61fbca8353e6b2f8a" title="Type of the material. Specifies how everything is blended together.">SMaterial::MaterialType</a> to use the renderer. -1 is returned if an error occured. -1 is returned for example if a vertex or pixel shader program could not be compiled, the error strings are then printed out into the error log, and can be catched with a custom event receiver. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="_i_g_p_u_programming_services_8h_source.html">IGPUProgrammingServices.h</a></li>
</ul>
</div>
<hr size="1">
<address style="align: right;">
<small> </small>
</address>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td width="0"> <div align="left"><small><a href="http://irrlicht.sourceforge.net" target="_blank"><img src="irrlicht.png" alt="The Irrlicht Engine" align="middle" border=0 width=88 height=31></a></small></div></td>
    <td> <div align="left"><small><em><font size="2">The <a href="http://irrlicht.sourceforge.net" target="_blank">Irrlicht 
        Engine</a> Documentation &copy; 2003-2010 by Nikolaus Gebhardt. Generated 
        on Sun Oct 24 12:42:09 2010 by <a href="http://www.doxygen.org" target="_blank">Doxygen</a> 
        (1.6.2)</font></em></small></div></td>
  </tr>
</table>
<address style="align: right;">
</address>
</body>
</html>
