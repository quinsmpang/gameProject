<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Irrlicht Engine: irr::core::array&lt; T, TAlloc &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table class="irrlicht" >
  <tr valign="middle"> 
    <td><font size="2"><a class="qindex" href="index.html"><font color="#FFFFFF">Home</font></a> 
      | <a class="qindex" href="namespaces.html"><font color="#FFFFFF">Namespaces</font></a> 
      | <a class="qindex" href="hierarchy.html"><font color="#FFFFFF">Hierarchy</font></a> 
      | <a class="qindex" href="classes.html"><font color="#FFFFFF">Alphabetical 
      List</font></a> | <a class="qindex" href="annotated.html"><font color="#FFFFFF"> 
      Class list</font></a> | <a class="qindex" href="files.html"><font color="#FFFFFF">Files</font></a> 
      | <a class="qindex" href="namespacemembers.html"><font color="#FFFFFF"> 
      Namespace&nbsp;Members</font></a> | <a class="qindex" href="functions.html"><font color="#FFFFFF">Class 
      members</font></a> | <a class="qindex" href="globals.html"><font color="#FFFFFF">File 
      members</font></a> | <a class="qindex" href="pages.html"><font color="#FFFFFF">Tutorials</font></a></font> </td>
  </tr>
</table>
<!-- Generated by Doxygen 1.6.2 -->
  <div class="navpath"><a class="el" href="namespaceirr.html">irr</a>::<a class="el" href="namespaceirr_1_1core.html">core</a>::<a class="el" href="classirr_1_1core_1_1array.html">array</a>
  </div>
<div class="contents">
<h1>irr::core::array&lt; T, TAlloc &gt; Class Template Reference</h1><!-- doxytag: class="irr::core::array" -->
<p>Self reallocating template array (like stl vector) with additional features.  
<a href="#_details">More...</a></p>

<p><code>#include &lt;<a class="el" href="irr_array_8h_source.html">irrArray.h</a>&gt;</code></p>

<p><a href="classirr_1_1core_1_1array-members.html">List of all members.</a></p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a2a15ea5df83792bce4366969d5b164c4">allocated_size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get amount of memory allocated.  <a href="#a2a15ea5df83792bce4366969d5b164c4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a4e584fd375dd5f994b6bd7afd7f7a60c">array</a> (const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor.  <a href="#a4e584fd375dd5f994b6bd7afd7f7a60c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ab58c4b2c09693190b43ee16e99722b43">array</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> start_count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Constructs an array and allocates an initial chunk of memory.  <a href="#ab58c4b2c09693190b43ee16e99722b43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a5e0dd817352068af92448a08716f1252">array</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default constructor for empty array.  <a href="#a5e0dd817352068af92448a08716f1252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ae2f68111b6899a63454d2956ee58ba6c">binary_search</a> (const T &amp;element, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> left, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> right) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a binary search for an element, returns -1 if not found.  <a href="#ae2f68111b6899a63454d2956ee58ba6c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#af9cd0644165ab0d40f97799acd3f2c22">binary_search</a> (const T &amp;element) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a binary search for an element if possible, returns -1 if not found.  <a href="#af9cd0644165ab0d40f97799acd3f2c22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a35412f669b983eaaf3792b82966db24a">binary_search</a> (const T &amp;element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Performs a binary search for an element, returns -1 if not found.  <a href="#a35412f669b983eaaf3792b82966db24a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a62821cac92125dd76f96f21e60ca94a4">binary_search_multi</a> (const T &amp;element, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &amp;last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a236e08ca44ddf3c2b47b726f90db8d39">clear</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears the array and deletes all allocated memory.  <a href="#a236e08ca44ddf3c2b47b726f90db8d39"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a8bf5bc844936a56632038524942f89f1">const_pointer</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a const pointer to the array.  <a href="#a8bf5bc844936a56632038524942f89f1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a1de2f5999968e104bf0ec6f057f097c2">empty</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Check if array is empty.  <a href="#a1de2f5999968e104bf0ec6f057f097c2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ab9bb8cb0e6ebc4839fa2f7bc8e626800">erase</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index, <a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> count)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases some elements from the array.  <a href="#ab9bb8cb0e6ebc4839fa2f7bc8e626800"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a5ba14e37dddaecd9c3e813a78c157dc8">erase</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Erases an element from the array.  <a href="#a5ba14e37dddaecd9c3e813a78c157dc8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ad531932175e210c17429878411490932">getLast</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets last element.  <a href="#ad531932175e210c17429878411490932"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ad87dc5db8bf6ec1033c945a0d3724e09">getLast</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets last element.  <a href="#ad87dc5db8bf6ec1033c945a0d3724e09"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a3b0f73c95dd449a4de576c6b1943566c">insert</a> (const T &amp;element, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index=0)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Insert item into array at specified position.  <a href="#a3b0f73c95dd449a4de576c6b1943566c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ac4a756f807ae06a74cc71cfd05dc22de">linear_reverse_search</a> (const T &amp;element) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an element in linear time, which is very slow.  <a href="#ac4a756f807ae06a74cc71cfd05dc22de"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a06327f3b1a87117a57a617cbb7738beb">linear_search</a> (const T &amp;element) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds an element in linear time, which is very slow.  <a href="#a06327f3b1a87117a57a617cbb7738beb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a20f435e8fabd821b66ef34227c1fceae">operator!=</a> (const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Inequality operator.  <a href="#a20f435e8fabd821b66ef34227c1fceae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a51c964d180507ebdef872d93886c23b2">operator=</a> (const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Assignment operator.  <a href="#a51c964d180507ebdef872d93886c23b2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a718e705f3e3561c49ceee75afe0c3251">operator==</a> (const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;other) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Equality operator.  <a href="#a718e705f3e3561c49ceee75afe0c3251"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a432981694ff74f416764bfbf71c76b4c">operator[]</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index) const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct const access operator.  <a href="#a432981694ff74f416764bfbf71c76b4c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a1e09dc5cc93e88fd3a37cad011b3b531">operator[]</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> index)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Direct access operator.  <a href="#a1e09dc5cc93e88fd3a37cad011b3b531"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a7b29797486e1c2ab3e7821082dab998c">pointer</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets a pointer to the array.  <a href="#a7b29797486e1c2ab3e7821082dab998c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ad2c9dff8592b95c25c59f5383fc633fe">push_back</a> (const T &amp;element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an element at back of array.  <a href="#ad2c9dff8592b95c25c59f5383fc633fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a31b686ce4b1ebae930f22bc40d30efbd">push_front</a> (const T &amp;element)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Adds an element at the front of the array.  <a href="#a31b686ce4b1ebae930f22bc40d30efbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a84e5d8a76ddfeb408168e4beb0d2d5d7">reallocate</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> new_size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocates the array, make it bigger or smaller.  <a href="#a84e5d8a76ddfeb408168e4beb0d2d5d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#afddd43e25d3ad6b1a3d75ceab13e6c56">set_free_when_destroyed</a> (bool f)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets if the array should delete the memory it uses upon destruction.  <a href="#afddd43e25d3ad6b1a3d75ceab13e6c56"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a75df5c46b08225d1ebe3c1381d85d9ff">set_pointer</a> (T *newPointer, <a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> size, bool _is_sorted=false, bool _free_when_destroyed=true)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets pointer to new array, using this as new workspace.  <a href="#a75df5c46b08225d1ebe3c1381d85d9ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#ab73d5838db931996f66f9efcc7127b49">set_sorted</a> (bool _is_sorted)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets if the array is sorted.  <a href="#ab73d5838db931996f66f9efcc7127b49"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a64d70ab89f03e2ec4deae3b6c0161305">set_used</a> (<a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> usedNow)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the size of the array and allocates new elements if necessary.  <a href="#a64d70ab89f03e2ec4deae3b6c0161305"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a7aef3e5dbf91f8d1e8f365039e2497ae">setAllocStrategy</a> (<a class="el" href="namespaceirr_1_1core.html#aa2e91971d5e6e84de235bfabe3c7adba">eAllocStrategy</a> newStrategy=ALLOC_STRATEGY_DOUBLE)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">set a new allocation strategy  <a href="#a7aef3e5dbf91f8d1e8f365039e2497ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#abc592bab637d54799b6c86d6d0e8adf8">size</a> () const </td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get number of occupied elements of the array.  <a href="#abc592bab637d54799b6c86d6d0e8adf8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a870e52dd57dd67a9d59e5ca5f82bca94">sort</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the array using heapsort.  <a href="#a870e52dd57dd67a9d59e5ca5f82bca94"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#a8857046f500a2990fc9930b204a3dbad">swap</a> (<a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;other)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Swap the content of this array container with the content of another array.  <a href="#a8857046f500a2990fc9930b204a3dbad"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1core_1_1array.html#aac1853f45d4c18feaacac9859efe9836">~array</a> ()</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor.  <a href="#aac1853f45d4c18feaacac9859efe9836"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt;<br/>
 class irr::core::array&lt; T, TAlloc &gt;</h3>

<p>Self reallocating template array (like stl vector) with additional features. </p>
<p>Some features are: Heap sorting, binary search methods, easier debugging. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00022">22</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a5e0dd817352068af92448a08716f1252"></a><!-- doxytag: member="irr::core::array::array" ref="a5e0dd817352068af92448a08716f1252" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::<a class="el" href="classirr_1_1core_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Default constructor for empty array. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00028">28</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab58c4b2c09693190b43ee16e99722b43"></a><!-- doxytag: member="irr::core::array::array" ref="ab58c4b2c09693190b43ee16e99722b43" args="(u32 start_count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::<a class="el" href="classirr_1_1core_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>start_count</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs an array and allocates an initial chunk of memory. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>start_count</em>&nbsp;</td><td>Amount of elements to pre-allocate. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00037">37</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4e584fd375dd5f994b6bd7afd7f7a60c"></a><!-- doxytag: member="irr::core::array::array" ref="a4e584fd375dd5f994b6bd7afd7f7a60c" args="(const array&lt; T, TAlloc &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::<a class="el" href="classirr_1_1core_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy constructor. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00046">46</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="aac1853f45d4c18feaacac9859efe9836"></a><!-- doxytag: member="irr::core::array::~array" ref="aac1853f45d4c18feaacac9859efe9836" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::~<a class="el" href="classirr_1_1core_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destructor. </p>
<p>Frees allocated memory, if set_free_when_destroyed was not set to false by the user before. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00055">55</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2a15ea5df83792bce4366969d5b164c4"></a><!-- doxytag: member="irr::core::array::allocated_size" ref="a2a15ea5df83792bce4366969d5b164c4" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::allocated_size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get amount of memory allocated. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Amount of memory allocated. The amount of bytes allocated would be <a class="el" href="classirr_1_1core_1_1array.html#a2a15ea5df83792bce4366969d5b164c4" title="Get amount of memory allocated.">allocated_size()</a> * sizeof(ElementTypeUsed); </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00368">368</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ae2f68111b6899a63454d2956ee58ba6c"></a><!-- doxytag: member="irr::core::array::binary_search" ref="ae2f68111b6899a63454d2956ee58ba6c" args="(const T &amp;element, s32 left, s32 right) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>right</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a binary search for an element, returns -1 if not found. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element,:</em>&nbsp;</td><td>Element to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>left</em>&nbsp;</td><td>First left index </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>right</em>&nbsp;</td><td>Last right index. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00428">428</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="af9cd0644165ab0d40f97799acd3f2c22"></a><!-- doxytag: member="irr::core::array::binary_search" ref="af9cd0644165ab0d40f97799acd3f2c22" args="(const T &amp;element) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a binary search for an element if possible, returns -1 if not found. </p>
<p>This method is for const arrays and so cannot call <a class="el" href="classirr_1_1core_1_1array.html#a870e52dd57dd67a9d59e5ca5f82bca94" title="Sorts the array using heapsort.">sort()</a>, if the array is not sorted then linear_search will be used instead. Potentially very slow! </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00413">413</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35412f669b983eaaf3792b82966db24a"></a><!-- doxytag: member="irr::core::array::binary_search" ref="a35412f669b983eaaf3792b82966db24a" args="(const T &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::binary_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Performs a binary search for an element, returns -1 if not found. </p>
<p>The array will be sorted before the binary search if it is not already sorted. Caution is advised! Be careful not to call this on unsorted const arrays, or the slower method will be used. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00400">400</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="irr_array_8h_source.html#l00400">irr::core::array&lt; IMesh * &gt;::binary_search()</a>, and <a class="el" href="irr_array_8h_source.html#l00466">irr::core::array&lt; IMesh * &gt;::binary_search_multi()</a>.</p>

</div>
</div>
<a class="anchor" id="a62821cac92125dd76f96f21e60ca94a4"></a><!-- doxytag: member="irr::core::array::binary_search_multi" ref="a62821cac92125dd76f96f21e60ca94a4" args="(const T &amp;element, s32 &amp;last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::binary_search_multi </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>last</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Performs a binary search for an element, returns -1 if not found. it is used for searching a multiset The array will be sorted before the binary search if it is not already sorted. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to search for. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>&amp;last</em>&nbsp;</td><td>return lastIndex of equal elements </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the first searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00466">466</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a236e08ca44ddf3c2b47b726f90db8d39"></a><!-- doxytag: member="irr::core::array::clear" ref="a236e08ca44ddf3c2b47b726f90db8d39" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Clears the array and deletes all allocated memory. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00194">194</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00190">irr::scene::SSkinMeshBuffer::convertTo2TCoords()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00209">irr::scene::SSkinMeshBuffer::convertToTangents()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00130">irr::scene::quake3::getAsStringList()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00769">irr::scene::quake3::getTextures()</a>, <a class="el" href="irr_array_8h_source.html#l00258">irr::core::array&lt; IMesh * &gt;::operator=()</a>, <a class="el" href="irr_array_8h_source.html#l00219">irr::core::array&lt; IMesh * &gt;::set_pointer()</a>, and <a class="el" href="irr_array_8h_source.html#l00055">irr::core::array&lt; IMesh * &gt;::~array()</a>.</p>

</div>
</div>
<a class="anchor" id="a8bf5bc844936a56632038524942f89f1"></a><!-- doxytag: member="irr::core::array::const_pointer" ref="a8bf5bc844936a56632038524942f89f1" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::const_pointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a const pointer to the array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the array. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00351">351</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00105">irr::scene::SSkinMeshBuffer::getIndices()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00074">irr::scene::SSharedMeshBuffer::getIndices()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00077">irr::scene::CMeshBuffer&lt; T &gt;::getIndices()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00059">irr::scene::SSkinMeshBuffer::getVertices()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00047">irr::scene::SSharedMeshBuffer::getVertices()</a>, and <a class="el" href="_c_mesh_buffer_8h_source.html#l00047">irr::scene::CMeshBuffer&lt; T &gt;::getVertices()</a>.</p>

</div>
</div>
<a class="anchor" id="a1de2f5999968e104bf0ec6f057f097c2"></a><!-- doxytag: member="irr::core::array::empty" ref="a1de2f5999968e104bf0ec6f057f097c2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if array is empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the array is empty false if not. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00376">376</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_animated_mesh_8h_source.html#l00057">irr::scene::SAnimatedMesh::getMesh()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00124">irr::scene::SAnimatedMesh::getMeshBuffer()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00114">irr::scene::SAnimatedMesh::getMeshBufferCount()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00135">irr::scene::SSkinMeshBuffer::recalculateBoundingBox()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00110">irr::scene::SSharedMeshBuffer::recalculateBoundingBox()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00092">irr::scene::SAnimatedMesh::recalculateBoundingBox()</a>, and <a class="el" href="_c_mesh_buffer_8h_source.html#l00118">irr::scene::CMeshBuffer&lt; T &gt;::recalculateBoundingBox()</a>.</p>

</div>
</div>
<a class="anchor" id="ab9bb8cb0e6ebc4839fa2f7bc8e626800"></a><!-- doxytag: member="irr::core::array::erase" ref="ab9bb8cb0e6ebc4839fa2f7bc8e626800" args="(u32 index, s32 count)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a>&nbsp;</td>
          <td class="paramname"> <em>count</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases some elements from the array. </p>
<p>May be slow, because all elements following after the erased element have to be copied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index,:</em>&nbsp;</td><td>Index of the first element to be erased. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count,:</em>&nbsp;</td><td>Amount of elements to be erased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00548">548</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5ba14e37dddaecd9c3e813a78c157dc8"></a><!-- doxytag: member="irr::core::array::erase" ref="a5ba14e37dddaecd9c3e813a78c157dc8" args="(u32 index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Erases an element from the array. </p>
<p>May be slow, because all elements following after the erased element have to be copied. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>index,:</em>&nbsp;</td><td>Index of element to be erased. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00527">527</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad531932175e210c17429878411490932"></a><!-- doxytag: member="irr::core::array::getLast" ref="ad531932175e210c17429878411490932" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::getLast </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets last element. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00333">333</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad87dc5db8bf6ec1033c945a0d3724e09"></a><!-- doxytag: member="irr::core::array::getLast" ref="ad87dc5db8bf6ec1033c945a0d3724e09" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::getLast </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets last element. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00324">324</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a3b0f73c95dd449a4de576c6b1943566c"></a><!-- doxytag: member="irr::core::array::insert" ref="a3b0f73c95dd449a4de576c6b1943566c" args="(const T &amp;element, u32 index=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Insert item into array at specified position. </p>
<p>Please use this only if you know what you are doing (possible performance loss). The preferred method of adding elements should be <a class="el" href="classirr_1_1core_1_1array.html#ad2c9dff8592b95c25c59f5383fc633fe" title="Adds an element at back of array.">push_back()</a>. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element,:</em>&nbsp;</td><td>Element to be inserted </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>index,:</em>&nbsp;</td><td>Where position to insert the new element. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00126">126</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="irr_array_8h_source.html#l00103">irr::core::array&lt; IMesh * &gt;::push_back()</a>, and <a class="el" href="irr_array_8h_source.html#l00114">irr::core::array&lt; IMesh * &gt;::push_front()</a>.</p>

</div>
</div>
<a class="anchor" id="ac4a756f807ae06a74cc71cfd05dc22de"></a><!-- doxytag: member="irr::core::array::linear_reverse_search" ref="ac4a756f807ae06a74cc71cfd05dc22de" args="(const T &amp;element) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::linear_reverse_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds an element in linear time, which is very slow. </p>
<p>Use binary_search for faster finding. Only works if ==operator is implemented. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element,:</em>&nbsp;</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00513">513</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a06327f3b1a87117a57a617cbb7738beb"></a><!-- doxytag: member="irr::core::array::linear_search" ref="a06327f3b1a87117a57a617cbb7738beb" args="(const T &amp;element) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#ac66849b7a6ed16e30ebede579f9b47c6">s32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::linear_search </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Finds an element in linear time, which is very slow. </p>
<p>Use binary_search for faster finding. Only works if ==operator is implemented. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to search for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Position of the searched element if it was found, otherwise -1 is returned. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00497">497</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="irr_array_8h_source.html#l00413">irr::core::array&lt; IMesh * &gt;::binary_search()</a>, and <a class="el" href="_i_q3_shader_8h_source.html#l00595">irr::scene::quake3::SVarGroup::get()</a>.</p>

</div>
</div>
<a class="anchor" id="a20f435e8fabd821b66ef34227c1fceae"></a><!-- doxytag: member="irr::core::array::operator!=" ref="a20f435e8fabd821b66ef34227c1fceae" args="(const array&lt; T, TAlloc &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inequality operator. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00299">299</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a51c964d180507ebdef872d93886c23b2"></a><!-- doxytag: member="irr::core::array::operator=" ref="a51c964d180507ebdef872d93886c23b2" args="(const array&lt; T, TAlloc &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt;T, TAlloc&gt;&amp; <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Assignment operator. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00258">258</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a718e705f3e3561c49ceee75afe0c3251"></a><!-- doxytag: member="irr::core::array::operator==" ref="a718e705f3e3561c49ceee75afe0c3251" args="(const array&lt; T, TAlloc &gt; &amp;other) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Equality operator. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00286">286</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a432981694ff74f416764bfbf71c76b4c"></a><!-- doxytag: member="irr::core::array::operator[]" ref="a432981694ff74f416764bfbf71c76b4c" args="(u32 index) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct const access operator. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00315">315</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a1e09dc5cc93e88fd3a37cad011b3b531"></a><!-- doxytag: member="irr::core::array::operator[]" ref="a1e09dc5cc93e88fd3a37cad011b3b531" args="(u32 index)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>index</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Direct access operator. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00306">306</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b29797486e1c2ab3e7821082dab998c"></a><!-- doxytag: member="irr::core::array::pointer" ref="a7b29797486e1c2ab3e7821082dab998c" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::pointer </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets a pointer to the array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Pointer to the array. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00343">343</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00111">irr::scene::SSkinMeshBuffer::getIndices()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00080">irr::scene::SSharedMeshBuffer::getIndices()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00085">irr::scene::CMeshBuffer&lt; T &gt;::getIndices()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00073">irr::scene::SSkinMeshBuffer::getVertices()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00056">irr::scene::SSharedMeshBuffer::getVertices()</a>, and <a class="el" href="_c_mesh_buffer_8h_source.html#l00055">irr::scene::CMeshBuffer&lt; T &gt;::getVertices()</a>.</p>

</div>
</div>
<a class="anchor" id="ad2c9dff8592b95c25c59f5383fc633fe"></a><!-- doxytag: member="irr::core::array::push_back" ref="ad2c9dff8592b95c25c59f5383fc633fe" args="(const T &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an element at back of array. </p>
<p>If the array is too small to add this new element it is made bigger. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element,:</em>&nbsp;</td><td>Element to add at the back of the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00103">103</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_animated_mesh_8h_source.html#l00067">irr::scene::SAnimatedMesh::addMesh()</a>, <a class="el" href="_s_mesh_8h_source.html#l00087">irr::scene::SMesh::addMeshBuffer()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00180">irr::scene::CMeshBuffer&lt; T &gt;::append()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00190">irr::scene::SSkinMeshBuffer::convertTo2TCoords()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00209">irr::scene::SSkinMeshBuffer::convertToTangents()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00130">irr::scene::quake3::getAsStringList()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00769">irr::scene::quake3::getTextures()</a>, <a class="el" href="_i_animated_mesh_m_d3_8h_source.html#l00265">irr::scene::SMD3QuaternionTagList::operator=()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00606">irr::scene::quake3::SVarGroup::set()</a>, and <a class="el" href="irr_string_8h_source.html#l01056">irr::core::string&lt; fschar_t &gt;::split()</a>.</p>

</div>
</div>
<a class="anchor" id="a31b686ce4b1ebae930f22bc40d30efbd"></a><!-- doxytag: member="irr::core::array::push_front" ref="a31b686ce4b1ebae930f22bc40d30efbd" args="(const T &amp;element)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&nbsp;</td>
          <td class="paramname"> <em>element</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds an element at the front of the array. </p>
<p>If the array is to small to add this new element, the array is made bigger. Please note that this is slow, because the whole array needs to be copied for this. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>element</em>&nbsp;</td><td>Element to add at the back of the array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00114">114</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a84e5d8a76ddfeb408168e4beb0d2d5d7"></a><!-- doxytag: member="irr::core::array::reallocate" ref="a84e5d8a76ddfeb408168e4beb0d2d5d7" args="(u32 new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::reallocate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>new_size</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Reallocates the array, make it bigger or smaller. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>new_size</em>&nbsp;</td><td>New size of array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00063">63</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_c_mesh_buffer_8h_source.html#l00180">irr::scene::CMeshBuffer&lt; T &gt;::append()</a>, <a class="el" href="irr_array_8h_source.html#l00037">irr::core::array&lt; IMesh * &gt;::array()</a>, <a class="el" href="irr_array_8h_source.html#l00126">irr::core::array&lt; IMesh * &gt;::insert()</a>, and <a class="el" href="irr_array_8h_source.html#l00248">irr::core::array&lt; IMesh * &gt;::set_used()</a>.</p>

</div>
</div>
<a class="anchor" id="afddd43e25d3ad6b1a3d75ceab13e6c56"></a><!-- doxytag: member="irr::core::array::set_free_when_destroyed" ref="afddd43e25d3ad6b1a3d75ceab13e6c56" args="(bool f)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::set_free_when_destroyed </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>f</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets if the array should delete the memory it uses upon destruction. </p>
<p>Also clear and set_pointer will only delete the (original) memory area if this flag is set to true, which is also the default. The methods reallocate, set_used, push_back, push_front, insert, and erase will still try to deallocate the original memory, which might cause troubles depending on the intended use of the memory area. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>f</em>&nbsp;</td><td>If true, the array frees the allocated memory in its destructor, otherwise not. The default is true. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00238">238</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a75df5c46b08225d1ebe3c1381d85d9ff"></a><!-- doxytag: member="irr::core::array::set_pointer" ref="a75df5c46b08225d1ebe3c1381d85d9ff" args="(T *newPointer, u32 size, bool _is_sorted=false, bool _free_when_destroyed=true)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::set_pointer </td>
          <td>(</td>
          <td class="paramtype">T *&nbsp;</td>
          <td class="paramname"> <em>newPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_is_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_free_when_destroyed</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets pointer to new array, using this as new workspace. </p>
<p>Make sure that set_free_when_destroyed is used properly. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newPointer,:</em>&nbsp;</td><td>Pointer to new array of elements. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size,:</em>&nbsp;</td><td>Size of the new array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_is_sorted</em>&nbsp;</td><td>Flag which tells whether the new array is already sorted. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>_free_when_destroyed</em>&nbsp;</td><td>Sets whether the new memory area shall be freed by the array upon destruction, or if this will be up to the user application. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00219">219</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab73d5838db931996f66f9efcc7127b49"></a><!-- doxytag: member="irr::core::array::set_sorted" ref="ab73d5838db931996f66f9efcc7127b49" args="(bool _is_sorted)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::set_sorted </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_is_sorted</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets if the array is sorted. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00575">575</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a64d70ab89f03e2ec4deae3b6c0161305"></a><!-- doxytag: member="irr::core::array::set_used" ref="a64d70ab89f03e2ec4deae3b6c0161305" args="(u32 usedNow)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::set_used </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a>&nbsp;</td>
          <td class="paramname"> <em>usedNow</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the size of the array and allocates new elements if necessary. </p>
<p>Please note: This is only secure when using it with simple types, because no default constructor will be called for the added elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>usedNow</em>&nbsp;</td><td>Amount of elements now used. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00248">248</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7aef3e5dbf91f8d1e8f365039e2497ae"></a><!-- doxytag: member="irr::core::array::setAllocStrategy" ref="a7aef3e5dbf91f8d1e8f365039e2497ae" args="(eAllocStrategy newStrategy=ALLOC_STRATEGY_DOUBLE)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::setAllocStrategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceirr_1_1core.html#aa2e91971d5e6e84de235bfabe3c7adba">eAllocStrategy</a>&nbsp;</td>
          <td class="paramname"> <em>newStrategy</em> = <code>ALLOC_STRATEGY_DOUBLE</code></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>set a new allocation strategy </p>
<p>if the maximum size of the array is unknown, you can define how big the allocation should happen. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>newStrategy</em>&nbsp;</td><td>New strategy to apply to this array. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00094">94</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_i_q3_shader_8h_source.html#l00576">irr::scene::quake3::SVarGroup::SVarGroup()</a>, and <a class="el" href="_i_q3_shader_8h_source.html#l00626">irr::scene::quake3::SVarGroupList::SVarGroupList()</a>.</p>

</div>
</div>
<a class="anchor" id="abc592bab637d54799b6c86d6d0e8adf8"></a><!-- doxytag: member="irr::core::array::size" ref="abc592bab637d54799b6c86d6d0e8adf8" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804">u32</a> <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get number of occupied elements of the array. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>Size of elements in the array which are actually occupied. </dd></dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00359">359</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00190">irr::scene::SSkinMeshBuffer::convertTo2TCoords()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00209">irr::scene::SSkinMeshBuffer::convertToTangents()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00738">irr::scene::quake3::dumpShader()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00694">irr::scene::quake3::dumpVarGroup()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00130">irr::scene::quake3::getAsStringList()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00043">irr::scene::SAnimatedMesh::getFrameCount()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00669">irr::scene::quake3::IShader::getGroup()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00662">irr::scene::quake3::IShader::getGroupSize()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00117">irr::scene::SSkinMeshBuffer::getIndexCount()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00086">irr::scene::SSharedMeshBuffer::getIndexCount()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00093">irr::scene::CMeshBuffer&lt; T &gt;::getIndexCount()</a>, <a class="el" href="_s_mesh_8h_source.html#l00050">irr::scene::SMesh::getMeshBuffer()</a>, <a class="el" href="_s_mesh_8h_source.html#l00037">irr::scene::SMesh::getMeshBufferCount()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00769">irr::scene::quake3::getTextures()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00087">irr::scene::SSkinMeshBuffer::getVertexCount()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00065">irr::scene::SSharedMeshBuffer::getVertexCount()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00063">irr::scene::CMeshBuffer&lt; T &gt;::getVertexCount()</a>, <a class="el" href="_i_q3_shader_8h_source.html#l00579">irr::scene::quake3::SVarGroup::isDefined()</a>, <a class="el" href="_s_skin_mesh_buffer_8h_source.html#l00135">irr::scene::SSkinMeshBuffer::recalculateBoundingBox()</a>, <a class="el" href="_s_shared_mesh_buffer_8h_source.html#l00110">irr::scene::SSharedMeshBuffer::recalculateBoundingBox()</a>, <a class="el" href="_s_mesh_8h_source.html#l00074">irr::scene::SMesh::recalculateBoundingBox()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00092">irr::scene::SAnimatedMesh::recalculateBoundingBox()</a>, <a class="el" href="_c_mesh_buffer_8h_source.html#l00118">irr::scene::CMeshBuffer&lt; T &gt;::recalculateBoundingBox()</a>, <a class="el" href="_i_animated_mesh_m_d3_8h_source.html#l00239">irr::scene::SMD3QuaternionTagList::set_used()</a>, <a class="el" href="_s_mesh_8h_source.html#l00111">irr::scene::SMesh::setDirty()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00161">irr::scene::SAnimatedMesh::setDirty()</a>, <a class="el" href="_s_mesh_8h_source.html#l00104">irr::scene::SMesh::setHardwareMappingHint()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00154">irr::scene::SAnimatedMesh::setHardwareMappingHint()</a>, <a class="el" href="_s_mesh_8h_source.html#l00097">irr::scene::SMesh::setMaterialFlag()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00147">irr::scene::SAnimatedMesh::setMaterialFlag()</a>, <a class="el" href="_s_animated_mesh_8h_source.html#l00033">irr::scene::SAnimatedMesh::~SAnimatedMesh()</a>, and <a class="el" href="_s_mesh_8h_source.html#l00029">irr::scene::SMesh::~SMesh()</a>.</p>

</div>
</div>
<a class="anchor" id="a870e52dd57dd67a9d59e5ca5f82bca94"></a><!-- doxytag: member="irr::core::array::sort" ref="a870e52dd57dd67a9d59e5ca5f82bca94" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::sort </td>
          <td>(</td>
          <td class="paramname"></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts the array using heapsort. </p>
<p>There is no additional memory waste and the algorithm performs O(n*log n) in worst case. </p>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00385">385</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="irr_array_8h_source.html#l00400">irr::core::array&lt; IMesh * &gt;::binary_search()</a>, and <a class="el" href="irr_array_8h_source.html#l00466">irr::core::array&lt; IMesh * &gt;::binary_search_multi()</a>.</p>

</div>
</div>
<a class="anchor" id="a8857046f500a2990fc9930b204a3dbad"></a><!-- doxytag: member="irr::core::array::swap" ref="a8857046f500a2990fc9930b204a3dbad" args="(array&lt; T, TAlloc &gt; &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, typename TAlloc = irrAllocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classirr_1_1core_1_1array.html">irr::core::array</a>&lt; T, TAlloc &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classirr_1_1core_1_1array.html">array</a>&lt; T, TAlloc &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>other</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Swap the content of this array container with the content of another array. </p>
<p>Afterwards this object will contain the content of the other object and the other object will contain the content of this object. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>other</em>&nbsp;</td><td>Swap content with this object </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="irr_array_8h_source.html#l00585">585</a> of file <a class="el" href="irr_array_8h_source.html">irrArray.h</a>.</p>

<p>Referenced by <a class="el" href="irr_array_8h_source.html#l00585">irr::core::array&lt; IMesh * &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="irr_array_8h_source.html">irrArray.h</a></li>
</ul>
</div>
<hr size="1">
<address style="align: right;">
<small> </small>
</address>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td width="0"> <div align="left"><small><a href="http://irrlicht.sourceforge.net" target="_blank"><img src="irrlicht.png" alt="The Irrlicht Engine" align="middle" border=0 width=88 height=31></a></small></div></td>
    <td> <div align="left"><small><em><font size="2">The <a href="http://irrlicht.sourceforge.net" target="_blank">Irrlicht 
        Engine</a> Documentation &copy; 2003-2010 by Nikolaus Gebhardt. Generated 
        on Sun Oct 24 12:42:03 2010 by <a href="http://www.doxygen.org" target="_blank">Doxygen</a> 
        (1.6.2)</font></em></small></div></td>
  </tr>
</table>
<address style="align: right;">
</address>
</body>
</html>
