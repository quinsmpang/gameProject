<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Irrlicht Engine: Tutorial 19: Mouse and Joystick</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<table class="irrlicht" >
  <tr valign="middle"> 
    <td><font size="2"><a class="qindex" href="index.html"><font color="#FFFFFF">Home</font></a> 
      | <a class="qindex" href="namespaces.html"><font color="#FFFFFF">Namespaces</font></a> 
      | <a class="qindex" href="hierarchy.html"><font color="#FFFFFF">Hierarchy</font></a> 
      | <a class="qindex" href="classes.html"><font color="#FFFFFF">Alphabetical 
      List</font></a> | <a class="qindex" href="annotated.html"><font color="#FFFFFF"> 
      Class list</font></a> | <a class="qindex" href="files.html"><font color="#FFFFFF">Files</font></a> 
      | <a class="qindex" href="namespacemembers.html"><font color="#FFFFFF"> 
      Namespace&nbsp;Members</font></a> | <a class="qindex" href="functions.html"><font color="#FFFFFF">Class 
      members</font></a> | <a class="qindex" href="globals.html"><font color="#FFFFFF">File 
      members</font></a> | <a class="qindex" href="pages.html"><font color="#FFFFFF">Tutorials</font></a></font> </td>
  </tr>
</table>
<!-- Generated by Doxygen 1.6.2 -->
<div class="contents">


<h1><a class="anchor" id="example019">Tutorial 19: Mouse and Joystick </a></h1><div align="center">
<img src="019shot.jpg" alt="019shot.jpg"/>
</div>
 <p>This tutorial builds on example 04.Movement which showed how to handle keyboard events in Irrlicht. Here we'll handle mouse events and joystick events, if you have a joystick connected and a device that supports joysticks. These are currently Windows, Linux and SDL devices. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#ifdef _MSC_VER</span>
<span class="preprocessor"></span><span class="comment">// We&#39;ll define this to stop MSVC complaining about sprintf().</span>
<span class="preprocessor">#define _CRT_SECURE_NO_WARNINGS</span>
<span class="preprocessor"></span><span class="preprocessor">#pragma comment(lib, &quot;Irrlicht.lib&quot;)</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;<a class="code" href="irrlicht_8h.html" title="Main header file of the irrlicht, the only file needed to include.">irrlicht.h</a>&gt;</span>
<span class="preprocessor">#include &quot;<a class="code" href="driver_choice_8h.html">driverChoice.h</a>&quot;</span>

<span class="keyword">using namespace </span>irr;
</pre></div><p>Just as we did in example 04.Movement, we'll store the latest state of the mouse and the first joystick, updating them as we receive events. </p>
<div class="fragment"><pre class="fragment"><span class="keyword">class </span>MyEventReceiver : <span class="keyword">public</span> IEventReceiver
{
<span class="keyword">public</span>:
        <span class="comment">// We&#39;ll create a struct to record info on the mouse state</span>
        <span class="keyword">struct </span>SMouseState
        {
                <a class="code" href="namespaceirr_1_1core.html#a3643c2cc7820dd78cd87e73a46b92145">core::position2di</a> Position;
                <span class="keywordtype">bool</span> LeftButtonDown;
                SMouseState() : LeftButtonDown(false) { }
        } MouseState;

        <span class="comment">// This is the one method that we have to implement</span>
        <span class="keyword">virtual</span> <span class="keywordtype">bool</span> OnEvent(<span class="keyword">const</span> SEvent&amp; event)
        {
                <span class="comment">// Remember the mouse state</span>
                <span class="keywordflow">if</span> (event.EventType == <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0caa230b748674e074aa67f661819ad5891" title="A mouse input event.">irr::EET_MOUSE_INPUT_EVENT</a>)
                {
                        <span class="keywordflow">switch</span>(event.MouseInput.Event)
                        {
                        <span class="keywordflow">case</span> <a class="code" href="namespaceirr.html#a2dbf2a247aa17a9eeefbbf36ebd5739fa3f551814f5f38596ea1f3ed7c6c7bad7" title="Left mouse button was pressed down.">EMIE_LMOUSE_PRESSED_DOWN</a>:
                                MouseState.LeftButtonDown = <span class="keyword">true</span>;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">case</span> <a class="code" href="namespaceirr.html#a2dbf2a247aa17a9eeefbbf36ebd5739fa26d91b99a8912ff622133f02c60f306a" title="Left mouse button was left up.">EMIE_LMOUSE_LEFT_UP</a>:
                                MouseState.LeftButtonDown = <span class="keyword">false</span>;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">case</span> <a class="code" href="namespaceirr.html#a2dbf2a247aa17a9eeefbbf36ebd5739fae3288f42ed4b8372853c1822bbc0a7a1" title="The mouse cursor changed its position.">EMIE_MOUSE_MOVED</a>:
                                MouseState.Position.X = <span class="keyword">event</span>.MouseInput.X;
                                MouseState.Position.Y = <span class="keyword">event</span>.MouseInput.Y;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">default</span>:
                                <span class="comment">// We won&#39;t use the wheel</span>
                                <span class="keywordflow">break</span>;
                        }
                }

                <span class="comment">// The state of each connected joystick is sent to us</span>
                <span class="comment">// once every run() of the Irrlicht device.  Store the</span>
                <span class="comment">// state of the first joystick, ignoring other joysticks.</span>
                <span class="comment">// This is currently only supported on Windows and Linux.</span>
                <span class="keywordflow">if</span> (event.EventType == <a class="code" href="namespaceirr.html#ac9eed96e06e85ce3c86fcbbbe9e48a0cac81558e4607ad260e96ae0f7b889e9a5" title="A joystick (joypad, gamepad) input event.">irr::EET_JOYSTICK_INPUT_EVENT</a>
                        &amp;&amp; event.JoystickEvent.Joystick == 0)
                {
                        JoystickState = <span class="keyword">event</span>.JoystickEvent;
                }

                <span class="keywordflow">return</span> <span class="keyword">false</span>;
        }

        <span class="keyword">const</span> SEvent::SJoystickEvent &amp; GetJoystickState(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">        </span>{
                <span class="keywordflow">return</span> JoystickState;
        }

        <span class="keyword">const</span> SMouseState &amp; GetMouseState(<span class="keywordtype">void</span>)<span class="keyword"> const</span>
<span class="keyword">        </span>{
                <span class="keywordflow">return</span> MouseState;
        }


        MyEventReceiver()
        {
        }

<span class="keyword">private</span>:
        SEvent::SJoystickEvent JoystickState;
};
</pre></div><p>The event receiver for keeping the pressed keys is ready, the actual responses will be made inside the render loop, right before drawing the scene. So lets just create an <a class="el" href="classirr_1_1_irrlicht_device.html" title="The Irrlicht device. You can create it with createDevice() or createDeviceEx().">irr::IrrlichtDevice</a> and the scene node we want to move. We also create some other additional scene nodes, to show that there are also some different possibilities to move and animate scene nodes. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main()
{
        <span class="comment">// ask user for driver</span>
        <a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0" title="An enum for all types of drivers the Irrlicht Engine supports.">video::E_DRIVER_TYPE</a> driverType=driverChoiceConsole();
        <span class="keywordflow">if</span> (driverType==<a class="code" href="namespaceirr_1_1video.html#ae35a6de6d436c76107ad157fe42356d0ae685cada50f8c100403134d932d0414c" title="No driver, just for counting the elements.">video::EDT_COUNT</a>)
                <span class="keywordflow">return</span> 1;

        <span class="comment">// create device</span>
        MyEventReceiver receiver;

        IrrlichtDevice* device = <a class="code" href="namespaceirr.html#abaf4d8719cc26b0d30813abf85e47c76" title="Creates an Irrlicht device. The Irrlicht device is the root object for using the...">createDevice</a>(driverType,
                        core::dimension2d&lt;u32&gt;(640, 480), 16, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, &amp;receiver);

        <span class="keywordflow">if</span> (device == 0)
                <span class="keywordflow">return</span> 1; <span class="comment">// could not create selected driver.</span>


        core::array&lt;SJoystickInfo&gt; joystickInfo;
        <span class="keywordflow">if</span>(device-&gt;activateJoysticks(joystickInfo))
        {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick support is enabled and &quot;</span> &lt;&lt; joystickInfo.size() &lt;&lt; <span class="stringliteral">&quot; joystick(s) are present.&quot;</span> &lt;&lt; std::endl;

                <span class="keywordflow">for</span>(<a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> joystick = 0; joystick &lt; joystickInfo.size(); ++joystick)
                {
                        std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick &quot;</span> &lt;&lt; joystick &lt;&lt; <span class="stringliteral">&quot;:&quot;</span> &lt;&lt; std::endl;
                        std::cout &lt;&lt; <span class="stringliteral">&quot;\tName: &#39;&quot;</span> &lt;&lt; joystickInfo[joystick].Name.c_str() &lt;&lt; <span class="stringliteral">&quot;&#39;&quot;</span> &lt;&lt; std::endl;
                        std::cout &lt;&lt; <span class="stringliteral">&quot;\tAxes: &quot;</span> &lt;&lt; joystickInfo[joystick].Axes &lt;&lt; std::endl;
                        std::cout &lt;&lt; <span class="stringliteral">&quot;\tButtons: &quot;</span> &lt;&lt; joystickInfo[joystick].Buttons &lt;&lt; std::endl;

                        std::cout &lt;&lt; <span class="stringliteral">&quot;\tHat is: &quot;</span>;

                        <span class="keywordflow">switch</span>(joystickInfo[joystick].PovHat)
                        {
                        <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_PRESENT:
                                std::cout &lt;&lt; <span class="stringliteral">&quot;present&quot;</span> &lt;&lt; std::endl;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_ABSENT:
                                std::cout &lt;&lt; <span class="stringliteral">&quot;absent&quot;</span> &lt;&lt; std::endl;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">case</span> SJoystickInfo::POV_HAT_UNKNOWN:
                        <span class="keywordflow">default</span>:
                                std::cout &lt;&lt; <span class="stringliteral">&quot;unknown&quot;</span> &lt;&lt; std::endl;
                                <span class="keywordflow">break</span>;
                        }
                }
        }
        <span class="keywordflow">else</span>
        {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Joystick support is not enabled.&quot;</span> &lt;&lt; std::endl;
        }

        <a class="code" href="namespaceirr_1_1core.html#aef83fafbb1b36fcce44c07c9be23a7f2" title="Typedef for wide character strings.">core::stringw</a> tmp = L<span class="stringliteral">&quot;Irrlicht Joystick Example (&quot;</span>;
        tmp += joystickInfo.size();
        tmp += <span class="stringliteral">&quot; joysticks)&quot;</span>;
        device-&gt;setWindowCaption(tmp.c_str());

        video::IVideoDriver* driver = device-&gt;getVideoDriver();
        scene::ISceneManager* smgr = device-&gt;getSceneManager();
</pre></div><p>We'll create an arrow mesh and move it around either with the joystick axis/hat, or make it follow the mouse pointer. </p>
<div class="fragment"><pre class="fragment">        scene::ISceneNode * node = smgr-&gt;addMeshSceneNode(
                smgr-&gt;addArrowMesh( <span class="stringliteral">&quot;Arrow&quot;</span>,
                                video::SColor(255, 255, 0, 0),
                                video::SColor(255, 0, 255, 0),
                                16,16,
                                2.f, 1.3f,
                                0.1f, 0.6f
                                )
                );
        node-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3acea597a2692b8415486a464a7f954d34" title="Will this material be lighted? Default: true.">video::EMF_LIGHTING</a>, <span class="keyword">false</span>);

        scene::ICameraSceneNode * camera = smgr-&gt;addCameraSceneNode();
        camera-&gt;setPosition(<a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, -10));

        <span class="comment">// As in example 04, we&#39;ll use framerate independent movement.</span>
        <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> then = device-&gt;getTimer()-&gt;getTime();
        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> MOVEMENT_SPEED = 5.f;

        <span class="keywordflow">while</span>(device-&gt;run())
        {
                <span class="comment">// Work out a frame delta time.</span>
                <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0416a53257075833e7002efd0a18e804" title="32 bit unsigned variable.">u32</a> now = device-&gt;getTimer()-&gt;getTime();
                <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> frameDeltaTime = (<a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a>)(now - then) / 1000.f; <span class="comment">// Time in seconds</span>
                then = now;

                <span class="keywordtype">bool</span> movedWithJoystick = <span class="keyword">false</span>;
                <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a> nodePosition = node-&gt;getPosition();

                <span class="keywordflow">if</span>(joystickInfo.size() &gt; 0)
                {
                        <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> moveHorizontal = 0.f; <span class="comment">// Range is -1.f for full left to +1.f for full right</span>
                        <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> moveVertical = 0.f; <span class="comment">// -1.f for full down to +1.f for full up.</span>

                        <span class="keyword">const</span> SEvent::SJoystickEvent &amp; joystickData = receiver.GetJoystickState();

                        <span class="comment">// We receive the full analog range of the axes, and so have to implement our</span>
                        <span class="comment">// own dead zone.  This is an empirical value, since some joysticks have more</span>
                        <span class="comment">// jitter or creep around the center point than others.  We&#39;ll use 5% of the</span>
                        <span class="comment">// range as the dead zone, but generally you would want to give the user the</span>
                        <span class="comment">// option to change this.</span>
                        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> DEAD_ZONE = 0.05f;

                        moveHorizontal =
                                (<a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a>)joystickData.Axis[SEvent::SJoystickEvent::AXIS_X] / 32767.f;
                        <span class="keywordflow">if</span>(fabs(moveHorizontal) &lt; DEAD_ZONE)
                                moveHorizontal = 0.f;

                        moveVertical =
                                (<a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a>)joystickData.Axis[SEvent::SJoystickEvent::AXIS_Y] / -32767.f;
                        <span class="keywordflow">if</span>(fabs(moveVertical) &lt; DEAD_ZONE)
                                moveVertical = 0.f;

                        <span class="comment">// POV hat info is only currently supported on Windows, but the value is</span>
                        <span class="comment">// guaranteed to be 65535 if it&#39;s not supported, so we can check its range.</span>
                        <span class="keyword">const</span> <a class="code" href="namespaceirr.html#ae9f8ec82692ad3b83c21f555bfa70bcc" title="16 bit unsigned variable.">u16</a> povDegrees = joystickData.POV / 100;
                        <span class="keywordflow">if</span>(povDegrees &lt; 360)
                        {
                                <span class="keywordflow">if</span>(povDegrees &gt; 0 &amp;&amp; povDegrees &lt; 180)
                                        moveHorizontal = 1.f;
                                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(povDegrees &gt; 180)
                                        moveHorizontal = -1.f;

                                <span class="keywordflow">if</span>(povDegrees &gt; 90 &amp;&amp; povDegrees &lt; 270)
                                        moveVertical = -1.f;
                                <span class="keywordflow">else</span> <span class="keywordflow">if</span>(povDegrees &gt; 270 || povDegrees &lt; 90)
                                        moveVertical = +1.f;
                        }

                        <span class="keywordflow">if</span>(!<a class="code" href="namespaceirr_1_1core.html#abf9b9b140cc365908ea4c8c47451e4e3" title="returns if a equals b, taking possible rounding errors into account">core::equals</a>(moveHorizontal, 0.f) || !<a class="code" href="namespaceirr_1_1core.html#abf9b9b140cc365908ea4c8c47451e4e3" title="returns if a equals b, taking possible rounding errors into account">core::equals</a>(moveVertical, 0.f))
                        {
                                nodePosition.X += MOVEMENT_SPEED * frameDeltaTime * moveHorizontal;
                                nodePosition.Y += MOVEMENT_SPEED * frameDeltaTime * moveVertical;
                                movedWithJoystick = <span class="keyword">true</span>;
                        }
                }

                <span class="comment">// If the arrow node isn&#39;t being moved with the joystick, then have it follow the mouse cursor.</span>
                <span class="keywordflow">if</span>(!movedWithJoystick)
                {
                        <span class="comment">// Create a ray through the mouse cursor.</span>
                        <a class="code" href="namespaceirr_1_1core.html#a384a3bb17659466af5521c7f74cfcea7" title="Typedef for an f32 line.">core::line3df</a> ray = smgr-&gt;getSceneCollisionManager()-&gt;getRayFromScreenCoordinates(
                                receiver.GetMouseState().Position, camera);

                        <span class="comment">// And intersect the ray with a plane around the node facing towards the camera.</span>
                        <a class="code" href="namespaceirr_1_1core.html#ae7491b7985dcb74b840bfcd9c054b232" title="Typedef for a f32 3d plane.">core::plane3df</a> plane(nodePosition, <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a>(0, 0, -1));
                        <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a> mousePosition;
                        <span class="keywordflow">if</span>(plane.getIntersectionWithLine(ray.start, ray.getVector(), mousePosition))
                        {
                                <span class="comment">// We now have a mouse position in 3d space; move towards it.</span>
                                <a class="code" href="namespaceirr_1_1core.html#a06f169d08b5c429f5575acb7edbad811" title="Typedef for a f32 3d vector.">core::vector3df</a> toMousePosition(mousePosition - nodePosition);
                                <span class="keyword">const</span> <a class="code" href="namespaceirr.html#a0277be98d67dc26ff93b1a6a1d086b07" title="32 bit floating point variable.">f32</a> availableMovement = MOVEMENT_SPEED * frameDeltaTime;

                                <span class="keywordflow">if</span>(toMousePosition.getLength() &lt;= availableMovement)
                                        nodePosition = mousePosition; <span class="comment">// Jump to the final position</span>
                                <span class="keywordflow">else</span>
                                        nodePosition += toMousePosition.normalize() * availableMovement; <span class="comment">// Move towards it</span>
                        }
                }

                node-&gt;setPosition(nodePosition);

                <span class="comment">// Turn lighting on and off depending on whether the left mouse button is down.</span>
                node-&gt;setMaterialFlag(<a class="code" href="namespaceirr_1_1video.html#a8a3bc00ae8137535b9fbc5f40add70d3acea597a2692b8415486a464a7f954d34" title="Will this material be lighted? Default: true.">video::EMF_LIGHTING</a>, receiver.GetMouseState().LeftButtonDown);

                driver-&gt;beginScene(<span class="keyword">true</span>, <span class="keyword">true</span>, video::SColor(255,113,113,133));
                smgr-&gt;drawAll(); <span class="comment">// draw the 3d scene</span>
                driver-&gt;endScene();
        }
</pre></div><p>In the end, delete the Irrlicht device. </p>
<div class="fragment"><pre class="fragment">        device-&gt;drop();

        <span class="keywordflow">return</span> 0;
}
</pre></div> </div>
<hr size="1">
<address style="align: right;">
<small> </small>
</address>
<table width="100%" border="0" cellspacing="0" cellpadding="2">
  <tr> 
    <td width="0"> <div align="left"><small><a href="http://irrlicht.sourceforge.net" target="_blank"><img src="irrlicht.png" alt="The Irrlicht Engine" align="middle" border=0 width=88 height=31></a></small></div></td>
    <td> <div align="left"><small><em><font size="2">The <a href="http://irrlicht.sourceforge.net" target="_blank">Irrlicht 
        Engine</a> Documentation &copy; 2003-2010 by Nikolaus Gebhardt. Generated 
        on Sun Oct 24 12:42:00 2010 by <a href="http://www.doxygen.org" target="_blank">Doxygen</a> 
        (1.6.2)</font></em></small></div></td>
  </tr>
</table>
<address style="align: right;">
</address>
</body>
</html>
